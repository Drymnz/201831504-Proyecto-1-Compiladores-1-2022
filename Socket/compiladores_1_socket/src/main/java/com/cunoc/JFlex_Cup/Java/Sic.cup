/*************************************CODE******************************************************/
package com.cunoc.JFlex_Cup.Java;
import java_cup.runtime.*;
    parser code {:
        Sintactico(Lexico lexico){
            super(lexico);
        }
        public void syntax_error(Symbol cur_token) {
        System.out.println("El error es el simbolo: " + sym.terminalNames[cur_token.sym]);
        System.out.println(String.format("En la posicion: %d, %d", cur_token.left, cur_token.right));
        }
        /*public void unrecovered_syntax_error(Symbol cur_token) {
            if (cur_token.sym == sym.EOF) {
             System.out.println("public void unrecoveredsyntax_error!!!!!!!!!!!!!!");
            }
        }*/
:}
/*************************************TERMINALES******************************************************/
/*************VARIABLES PRIMITIVAS***************/
terminal BYTE,SHORT,INT,LONG,FLOAT,F,DOUBLE;//num
terminal CHAR,CARACTER,CHARTN;//CARACTER
terminal BOOLEAN,TRUE,FALSE,ADMIRACION,INTERO;//boolean
/*ENCABEZADO*/
terminal PACKAGE,IMPORT;
/*************PUNTUACION***************/
terminal PUNTO,PUNTO_COMA,SIMPLE_COMILLA,DOBLE_PUNTO,COMA;//PUNTUACION
/*************CLASE***************/
terminal CLASS,THIS;
terminal EXNTENDS,IMPLEMENTS,SUPER;//HERENCIA
/*************TODAS PARTES***************/
terminal NEW,VOID;
/*TRY CATCH*/
terminal TRY,CATCH;
/*SENTENCIAS DE CONTORL*/
terminal FOR,WHILE,DO,IF,ELSE,SWITCH,CASE,DEFAULT;
/*FINAL SENTENCIAS DE CONTORL*/ 
terminal BREAK,RETURN;
/*VISIBILIDA*/ 
terminal PRIVATE,PUBLIC,PROTECTED;
terminal FINAL,STATIC;//USO DE MEMORIA
/****************************/
terminal String DECIMAL,ENTERO,ID,STRING;//TOKEN 
terminal Stirng TEXT;
terminal SUMA,RESTA,MULTIPLICACION,DIVISION;//OPERACION
terminal IGUAL,MODULO;//= 
/*SIMBOLOS OPERADOR RELACIONALES*/
terminal MENOR_Q,MAYOR_Q,Y,O;
/**************************AGRUPACION********************************/
terminal P_APERTURA,P_CIERRE,L_APERTURA,L_CIERRE,C_APERTURA,C_CIERRE;
/*************************************NO TERMINALES******************************************************/
non terminal inicio;//INICIO DE TODO
/*c , d , g ,h ,i , k , q ,r,e,w,z,f,u,s,b,n,m,a,l  */
non terminal String operaionNumerica,j;//operaciones
/*LA PARTE DE package Y import*/
non terminal encabezado,importacion,p,sp,spp,pc,vfactorizadoStatic,vfactorizadoVC;
/*LA CLASE*/
non terminal clase,internoClase,vc,staticCfianl,v,internoClaseFa,ayuda;
/*VARIABLE GLOBAL O asignacionVariable DE LA CALSE*/
non terminal asignacionVariable,vGlobal,vChar;
non terminal numFloat,numEntero, numDouble, variableChar, variableBoolean,dosY,dosO,variableStirng, variableObject;
non terminal dSeguidoF,tDatos,variableID,objectInst,vGlobalFac,tDataP,operadores;
/*METODOS*/
non terminal metodo,pMetodoS,pMetodoSP;
non terminal onlyIDArray,staticFactori,finalFactori;
non terminal idDatoFac ,tFact,lCon, idDato;
/*LOCAL METODO*/
non terminal variableLocal,local,localMetodo,lConFact,loclaMetodFacto,terminalAccion;
non terminal variableObjectUsarCrear,variableIDLocal,variableSet,usarOBJECT,idGet,variableLocalFinal;
/*SENTENCIAS DE CONTROLS*/
non terminal sentenciaControl,usarVariable,restarIgual,sumarIgual,usarVariableFacto;
non terminal variableIDFor,sentenciaFor,inializarVariable,forVariableId,forVariableIdFac;
non terminal sentenciaElse,sentenciaElseFac,operarBoolean,opBooleanIGUALFac,textOperar,tDatosFac;
/*************************************PRECEDENCIA******************************************************/
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION;
precedence left IGUAL,MAYOR_Q,MENOR_Q, Y;
precedence left IGUAL,MAYOR_Q,MENOR_Q, O;
/*************************************GRAMATICA******************************************************/
start with inicio;
/******INICIO DE TODO *****/
inicio ::={:System.out.println("COMENZO EL ANALISIS");:} encabezado clase {:System.out.println("TERMINO EL ANALISIS");:};
/*****PRIMERA PARTE*******/
encabezado ::= PACKAGE ID pc importacion
|importacion
;
//punto id ; , punto id punto id ;
pc ::= PUNTO ID pc
| p
;
importacion ::= IMPORT ID sp importacion
|
;
// punto id, ; , punto * ; , punto id punto * ;
sp ::= PUNTO spp
| p
;
spp ::= MULTIPLICACION p
| ID sp
;
p ::=  PUNTO_COMA
| error {:System.out.println("te falto colocar ;");:}
;
/*****FINAL PRIMERA PARTE****/
/*PARTE DE LA CLASE ******************************************************* CLASE CLASE*/
clase ::= v CLASS ID L_APERTURA  internoClase  L_CIERRE
;
/*VISIBILIDAD DE LAS CLASES*/
// STATIC FINAL, STATIC ,FINAL STATIC ,FINAL ,STATIC FINAL vc, STATIC vc ,FINAL STATIC vc,FINAL  vc
// vc STATIC FINAL,vc STATIC , vc FINAL STATIC ,vc FINAL
v ::= staticCfianl vfactorizadoStatic
| vc vfactorizadoVC
;
vfactorizadoStatic ::= vc
|
;
vfactorizadoVC ::= staticCfianl
|
;
staticCfianl ::= STATIC staticFactori
|FINAL finalFactori
;
//*
staticFactori ::= FINAL
|
;
finalFactori ::= STATIC
|
;
vc ::= PUBLIC
| PRIVATE
| PROTECTED
;
/*FIANAL VISIBILIDAD DE LAS CLASES*/
internoClase ::= vGlobal internoClaseFa
| 
;
/*VISIBILIDAD DE LAS VARIALBES DE ATRIBUTOS O METODOS DE UNA CLASE*/
vGlobal ::= vc vGlobalFac 
| vGlobalFac
;
vGlobalFac ::= staticCfianl
| 
;
internoClaseFa ::= variableID ayuda
|ayuda
;
/*AQUIE SE DIFERENCIA SI ES UNA METODO O ATRIBUTO*/
ayuda ::= asignacionVariable internoClase
| metodo internoClase
;
/*****************VARIABLE**************/
variableID ::= numFloat 
| numDouble 
| variableChar 
| variableBoolean 
| variableStirng 
| variableObject 
| numEntero 
;
numFloat ::= FLOAT onlyIDArray;
numDouble ::= DOUBLE onlyIDArray;
variableChar ::= CHAR onlyIDArray;
variableBoolean ::=BOOLEAN onlyIDArray;
variableStirng ::= STRING onlyIDArray;
variableObject ::= ID onlyIDArray;
numEntero ::= BYTE onlyIDArray
| SHORT onlyIDArray
| INT onlyIDArray
| LONG onlyIDArray 
;
//arreay [] | ID
onlyIDArray ::= ID 
| C_APERTURA C_CIERRE onlyIDArray
;
/*****************FINAL VARIABLE**************/
/*****************VARIABLES INDIALIZADAS DE UNA CLASE**************/
asignacionVariable ::=  IGUAL tDatos p
|p
;
tDatos ::= P_APERTURA tDatos P_CIERRE tDatosFac
|tDataP
;
//el uso del ()? tDatos : tDatos | ()? tDatos : ()? tDatos : tDatos
tDatosFac ::= 
| INTERO tDatos DOBLE_PUNTO tDatos
;
tDataP ::= operadores
|vChar
|F
|L_APERTURA lCon
|NEW ID P_APERTURA  tFact
;
//para los char
vChar ::= SIMPLE_COMILLA CARACTER SIMPLE_COMILLA
| CHARTN
;
//esto para new id (parametos de objetos)
tFact ::= dSeguidoF P_CIERRE 
| P_CIERRE 
;
dSeguidoF ::= tDatos objectInst
;
objectInst ::= COMA dSeguidoF
|
;
// esto para crear arreglos{}
lCon ::= tDatos lConFact L_CIERRE
| L_CIERRE
;
lConFact ::=  COMA tDatos  lConFact
|
;
/*OPERADORES*/
operadores::= operarBoolean
;
/*FINAL OPERADORES*/
operarBoolean ::= operarBoolean IGUAL IGUAL operarBoolean 
|operarBoolean MAYOR_Q opBooleanIGUALFac
|operarBoolean MENOR_Q opBooleanIGUALFac
|operarBoolean Y dosY operarBoolean
|operarBoolean O dosO operarBoolean 
|FALSE
|TRUE
|ADMIRACION operarBoolean
|j
|C_APERTURA j C_CIERRE
;
textOperar ::= SUMA operadores
|
;
dosY ::= Y
|
;
dosO ::= O
|
;
opBooleanIGUALFac ::=  operarBoolean
| IGUAL operarBoolean
;
/*OPERACION NUMERICA*/
j ::= operaionNumerica {::}
;
operaionNumerica ::= operaionNumerica SUMA operaionNumerica 
| operaionNumerica RESTA operaionNumerica 
| operaionNumerica DIVISION operaionNumerica
| operaionNumerica MULTIPLICACION operaionNumerica
| RESTA operaionNumerica
| SUMA operaionNumerica
| ENTERO
| DECIMAL
| TEXT textOperar
| usarOBJECT
;
//USAR OBJECT
usarOBJECT ::= ID idDato;
//ARRAY.LETER - 4 ,ID.ID(); //GET
idDato ::= PUNTO idDatoFac
|C_APERTURA j C_CIERRE idDato
|P_APERTURA dSeguidoF P_CIERRE
|
;
idDatoFac ::= ID  idGet
;
idGet ::= idDato
| P_APERTURA P_CIERRE 
;
/*****************FINAL VARIABLES INDIALIZADAS DE UNA CLASE**************/
/***********************************METODOS**************/
metodo ::= P_APERTURA pMetodoS P_CIERRE L_APERTURA {:System.out.println("**********************************************************INICIO METODO*************************");:} localMetodo {:System.out.println("****FINAL METODO");:} L_CIERRE 
|VOID  ID P_APERTURA pMetodoS P_CIERRE L_APERTURA {:System.out.println("**********************************************************INICIO METODO*************************");:} localMetodo  {:System.out.println("****FINAL METODO");:} L_CIERRE
|ID P_APERTURA pMetodoS P_CIERRE L_APERTURA {:System.out.println("**********************************************************INICIO METODO*************************");:} localMetodo  {:System.out.println("****FINAL METODO");:} L_CIERRE
;
//peticiiones de metodos
pMetodoS ::= variableID pMetodoSP
|
;
pMetodoSP ::= COMA pMetodoS
| 
;
/***********************************FINAL METODOS**************/
/*LO QUE SE PUEDE HACER DENTRO DE UN METODO*/
localMetodo ::= local  localMetodo
|
;
local ::= variableLocal
|{:System.out.println("************************SENTENCIA DE CONTORL********");:}
sentenciaControl
{:System.out.println("************************FINAL SENTENCIA DE CONTORL********");:}
|terminalAccion
;
/*VARIALBES LOCALES DENTRO DE UN METODO*/
variableLocal ::= variableLocalFinal asignacionVariable
;
//VARIABLE FINAL 
variableLocalFinal ::= FINAL variableIDLocal
|variableIDLocal
|usarVariable
|terminalAccion
;
variableIDLocal ::= numFloat 
| numDouble 
| variableChar 
| variableBoolean 
| variableStirng  
| numEntero 
;
//asignar al set
loclaMetodFacto ::= PUNTO  ID  variableObjectUsarCrear
|
;
variableObjectUsarCrear ::= P_APERTURA variableSet
|loclaMetodFacto
;
variableSet ::= tDatos P_CIERRE 
|P_CIERRE
;
/*CUALQUIER ACCION menos colocar otra sentencia ya no es*/
usarVariable ::= ID usarVariableFacto
|THIS loclaMetodFacto
|SUPER loclaMetodFacto
;
// id ++ id-- id+= id -=
usarVariableFacto ::= SUMA sumarIgual
|RESTA restarIgual
|loclaMetodFacto
|IGUAL tDatos
|C_APERTURA j C_CIERRE loclaMetodFacto
;
restarIgual ::= IGUAL tDatos
| RESTA
;
sumarIgual ::= IGUAL tDatos
| SUMA
;
terminalAccion ::= RETURN tDatos p
|BREAK p
;
/*VARIALBES LOCALES DENTRO DE UN METODO*/
/*SENTENCIAS DE CONTROL*/
sentenciaControl ::= WHILE P_APERTURA operadores P_CIERRE L_APERTURA localMetodo L_CIERRE
|DO L_APERTURA localMetodo L_CIERRE WHILE P_APERTURA operadores P_CIERRE p
|IF P_APERTURA operadores P_CIERRE L_APERTURA localMetodo L_CIERRE sentenciaElse
//|SWITCH P_APERTURA operadores P_CIERRE L_APERTURA CASE j DOBLE_PUNTO localMetodo BREAK p L_CIERRE
//|SWITCH P_APERTURA operadores P_CIERRE L_APERTURA CASE j DOBLE_PUNTO localMetodo BREAK p DEFAULT DOBLE_PUNTO localMetodo BREAK p L_CIERRE
//|SWITCH P_APERTURA operadores P_CIERRE L_APERTURA CASE j DOBLE_PUNTO localMetodo BREAK p CASE j DOBLE_PUNTO localMetodo BREAK p L_CIERRE
//|SWITCH P_APERTURA ID P_CIERRE
|FOR P_APERTURA inializarVariable  sentenciaFor
;
sentenciaFor ::=  P_CIERRE L_APERTURA localMetodo L_CIERRE
| operadores p usarVariable  P_CIERRE L_APERTURA localMetodo L_CIERRE
;
inializarVariable ::= variableIDFor asignacionVariable
| ID forVariableId
;  
variableIDFor ::= numFloat 
| numDouble 
| variableChar 
| variableBoolean 
| variableStirng 
| numEntero 
;
forVariableId ::= ID forVariableIdFac
| C_APERTURA C_CIERRE forVariableId
;
forVariableIdFac ::= DOBLE_PUNTO ID
| asignacionVariable
;
//USO DE IF ELSE IF ELSE
sentenciaElse ::= ELSE  sentenciaElseFac
|
;
sentenciaElseFac ::= L_APERTURA localMetodo L_CIERRE
|IF P_APERTURA operadores P_CIERRE L_APERTURA localMetodo L_CIERRE sentenciaElse
;
/*FINAL SENTENCIAS DE CONTROL*/
/*FINAL LO QUE SE PUEDE HACER DENTRO DE UN METODO*/
/*FINAL PARTE DE LA CLASE*/
/