/*************************************CODE******************************************************/
package com.cunoc.JFlex_Cup.Java;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;

import com.cunoc.Server.Console;
import com.cunoc.JFlex_Cup.Java.repetition.ListType;
import com.cunoc.JFlex_Cup.Java.repetition.Method;
import com.cunoc.JFlex_Cup.Java.repetition.Variable;
import com.cunoc.JFlex_Cup.Java.repetition.ClassSyntax;
    parser code {:
        private ClassSyntax classFinalSystax ;
        private ListType typeDate = null;
        private ListType typeMethods = null;
        private Symbol s;
        private String nameClass;
        private String nameVariable;
        private String nameMethods;
        private List<Method> ListMethods =new ArrayList<>();
        private List<Variable> ListVariable= new ArrayList<>();
        private List<Variable> listParameters= new ArrayList<>();
        private int errorCounter= 0;

        Sintactico(Lexico lexico){
            super(lexico);
        }
        public void syntax_error(Symbol cur_token) {
            errorCounter++;
            Console.ConsoleText.append("\n"+errorCounter+" - Clase<"+nameClass+"> en simbolo<" + sym.terminalNames[cur_token.sym]+String.format(">posicion: <%d>, <%d>", (cur_token.left+1), (cur_token.right+1)));
        }
        /*public void unrecovered_syntax_error(Symbol cur_token) {
            if (cur_token.sym == sym.EOF) {
             System.out.println("public void unrecoveredsyntax_error!!!!!!!!!!!!!!");
            }
        }*/
        public Symbol getSymbol(){
            return this.s;
        }

       private void addVariable (int aleft,int aright){
          /*  System.out.println("***************VARIABLE******************");
            System.out.println("tipo:"+typeDate+"x:"+(aright+1)+"y:"+(aleft+1)+"name:"+nameVariable);
            System.out.println("****************************************");*/
            ListVariable.add(new Variable(typeDate,aright+1,aleft+1,nameVariable));
            typeDate=null;
            nameVariable = "";
        }
        private void addMethods (int aleft,int aright){
            /*
            System.out.println("***************METODOS******************");
            System.out.println("tipo:"+typeDate+"x:"+(aright+1)+"y:"+(aleft+1)+"name:"+nameMethods);
            System.out.println("****************************************");*/
            if(typeMethods ==null){
                typeMethods = ListType.CONSTRUCTOR;
            }
            ListMethods.add(new Method(typeMethods, listParameters, (aright+1), (aleft+1), nameMethods));
            listParameters =  new ArrayList<>();
            typeMethods=null;
            nameVariable = "";
        }
        private void addMethodsParameters (int aleft,int aright){
            /*System.out.println("*Methods Parameters");
            System.out.println("tipo:"+typeDate+"x:"+(aright+1)+"y:"+(aleft+1)+"name:"+nameVariable);
            System.out.println("****************************************");*/
            listParameters.add(new Variable(typeDate,aright+1,aleft+1,nameVariable));
            typeDate=null;
            nameVariable = "";
        }
        public void arrayType() {
        switch (typeDate) {
            case BYTE:
                typeDate = ListType.ARRAYBYTE;
                break;
            case SHORT:
                typeDate = ListType.ARRAYSHORT;
                break;
            case INT:
                typeDate = ListType.ARRAYINT;
                break;
            case LONG:
                typeDate = ListType.ARRAYLONG;
                break;
            case FLOAT:
                typeDate = ListType.ARRAYFLOAT;
                break;
            case DOUBLE:
                typeDate = ListType.ARRAYDOUBLE;
                break;
            case CHAR:
                typeDate = ListType.ARRAYCHAR;
                break;
            case BOOLEAN:
                typeDate = ListType.ARRAYBOOLEAN;
                break;
            case STRING:
                typeDate = ListType.ARRAYSTRING;
                break;
            case OBJECT:
                typeDate = ListType.ARRAYOBJECT;
                break;
            default:
                break;
        }
    }
    public String getNameClass(){
        return this.nameClass;
    }
        public int getErrorCounter(){
            return this.errorCounter;
        }
        public List<Variable> getListVariable() {
        return ListVariable;
        }
        public List<Method> getListMethods() {
        return ListMethods;
        }
        public ClassSyntax getClassSyntax(){
            return this.classFinalSystax;
        }
:}
/*************************************TERMINALES******************************************************/
/*************VARIABLES PRIMITIVAS***************/
terminal String BYTE,SHORT,INT,LONG,FLOAT,F,DOUBLE;//num
terminal String CHAR,CARACTER,CHARTN;//CARACTER
terminal String BOOLEAN,TRUE,FALSE,ADMIRACION,INTERO;//boolean
/*ENCABEZADO*/
terminal PACKAGE,IMPORT;
/*************PUNTUACION***************/
terminal PUNTO,PUNTO_COMA,SIMPLE_COMILLA,DOBLE_PUNTO,COMA;//PUNTUACION
/*************CLASE***************/
terminal CLASS,THIS;
terminal EXNTENDS,IMPLEMENTS,SUPER;//HERENCIA
/*************TODAS PARTES***************/
terminal NEW,VOID;
/*TRY CATCH*/
terminal TRY,CATCH;
/*SENTENCIAS DE CONTORL*/
terminal FOR,WHILE,DO,IF,ELSE,SWITCH,CASE,DEFAULT;
/*FINAL SENTENCIAS DE CONTORL*/ 
terminal BREAK,RETURN;
/*VISIBILIDA*/ 
terminal PRIVATE,PUBLIC,PROTECTED;
terminal FINAL,STATIC;//USO DE MEMORIA
/****************************/
terminal String DECIMAL,ENTERO,ID,STRING;//TOKEN 
terminal Stirng TEXT;
terminal SUMA,RESTA,MULTIPLICACION,DIVISION;//OPERACION
terminal IGUAL,MODULO;//= 
/*SIMBOLOS OPERADOR RELACIONALES*/
terminal MENOR_Q,MAYOR_Q,Y,O;
/**************************AGRUPACION********************************/
terminal P_APERTURA,P_CIERRE,L_APERTURA,L_CIERRE,C_APERTURA,C_CIERRE;
/*************************************NO TERMINALES******************************************************/
non terminal inicio;//INICIO DE TODO
/*c , d , g ,h ,i , k , q ,r,e,w,z,f,u,s,b,n,m,a,l  */
non terminal String operaionNumerica,j;//operaciones
/*LA PARTE DE package Y import*/
non terminal encabezado,importacion,p,sp,spp,pc,vfactorizadoStatic,vfactorizadoVC;
/*LA CLASE*/
non terminal clase,internoClase,vc,staticCfianl,v,internoClaseFa,ayuda,herencia,secuenciIDHRE;
/*VARIABLE GLOBAL O asignacionVariable DE LA CALSE*/
non terminal asignacionVariable,vGlobal,vChar;
non terminal numFloat,numEntero, numDouble, variableChar, variableBoolean,dosY,dosO,variableStirng, variableObject;
non terminal dSeguidoF,tDatos,variableID,objectInst,vGlobalFac;
/*METODOS*/
non terminal metodo,pMetodoS,pMetodoSP,soloId;
non terminal onlyIDArray,staticFactori,finalFactori;
non terminal idDatoFac ,tFact,lCon, idDato;
/*LOCAL METODO*/
non terminal variableLocal,local,localMetodo,lConFact,loclaMetodFacto,terminalAccion;
non terminal variableObjectUsarCrear,variableIDLocal,variableSet,usarOBJECT,idGet,variableLocalFinal;
/*SENTENCIAS DE CONTROLS*/
non terminal sentenciaControl,usarVariable,restarIgual,sumarIgual,usarVariableFacto;
non terminal variableIDFor,sentenciaFor,inializarVariable,forVariableId,forVariableIdFac;
non terminal sentenciaElse,sentenciaElseFac,opBooleanIGUALFac,textOperar,tDatosFac;
non terminal internoSwitch,localSwitch,localSwitchDeclaracion,menorYmayorIgual;
non terminal operacionNumericaRecusividad,operacionNumericaPrima,operacionNumericaTerminales,igualSimple;
non terminal secuenciDatos,typeVarible,newParentesisOCochtes;
/*************************************PRECEDENCIA******************************************************/
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION;
precedence left DIVISION, MODULO;
precedence left ADMIRACION,IGUAL,MAYOR_Q,MENOR_Q, Y;
precedence left ADMIRACION,IGUAL,MAYOR_Q,MENOR_Q, O;
/*************************************GRAMATICA******************************************************/
start with inicio;
/******INICIO DE TODO *****/
inicio ::= encabezado clase {:classFinalSystax = new ClassSyntax(nameClass, ListMethods, ListVariable, null);:} 
;
/*****PRIMERA PARTE*******/
encabezado ::= PACKAGE ID pc importacion
|importacion
;
//punto id ; , punto id punto id ;
pc ::= PUNTO ID pc
| p
;
importacion ::= IMPORT ID sp importacion
|
;
// punto id, ; , punto * ; , punto id punto * ;
sp ::= PUNTO spp
| p
;
spp ::= MULTIPLICACION p
| ID sp
;
p ::=  PUNTO_COMA
| error {:System.out.println("te falto colocar ;");:}
;
/*****FINAL PRIMERA PARTE****/
/*PARTE DE LA CLASE ******************************************************* CLASE CLASE*/
clase ::= v CLASS ID:a {:nameClass = a.toString();:} herencia L_APERTURA  internoClase  L_CIERRE
;
herencia ::= 
| EXNTENDS ID secuenciIDHRE herencia
| IMPLEMENTS ID secuenciIDHRE herencia
;
secuenciIDHRE ::= PUNTO ID secuenciIDHRE
|
;
/*VISIBILIDAD DE LAS CLASES*/
// STATIC FINAL, STATIC ,FINAL STATIC ,FINAL ,STATIC FINAL vc, STATIC vc ,FINAL STATIC vc,FINAL  vc
// vc STATIC FINAL,vc STATIC , vc FINAL STATIC ,vc FINAL
v ::= staticCfianl vfactorizadoStatic
| vc vfactorizadoVC
;
vfactorizadoStatic ::= vc
|
;
vfactorizadoVC ::= staticCfianl
|
;
staticCfianl ::= STATIC staticFactori
|FINAL finalFactori
;
//*
staticFactori ::= FINAL
|
;
finalFactori ::= STATIC
|
;
vc ::= PUBLIC
| PRIVATE
| PROTECTED
;
/*FIANAL VISIBILIDAD DE LAS CLASES*/
internoClase ::= vGlobal internoClaseFa
| 
;
/*VISIBILIDAD DE LAS VARIALBES DE ATRIBUTOS O METODOS DE UNA CLASE*/
vGlobal ::= vc vGlobalFac 
| vGlobalFac
;
vGlobalFac ::= staticCfianl
| 
;
internoClaseFa ::= variableID ayuda
|ayuda
;
/*AQUIE SE DIFERENCIA SI ES UNA METODO O ATRIBUTO*/
ayuda ::= asignacionVariable {:
            int aleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		    int aright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
            addVariable(aleft,aright);
            :} 
              internoClase 
| metodo 
 {:
            int aleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		    int aright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
            addMethods(aleft,aright);
            :}
internoClase
;
/*****************VARIABLE**************/
variableID ::= numFloat 
| numDouble 
| variableChar 
| variableBoolean 
| variableStirng 
| variableObject 
| numEntero 
;
typeVarible ::= ID
|FLOAT
|DOUBLE
|CHAR
|BOOLEAN
|STRING
|BYTE
|SHORT
|INT
|LONG
;
numFloat ::= FLOAT {:typeDate = ListType.FLOAT;:} onlyIDArray;
numDouble ::= DOUBLE {:typeDate = ListType.DOUBLE;:}  onlyIDArray;
variableChar ::= CHAR {:typeDate = ListType.CHAR;:} onlyIDArray;
variableBoolean ::=BOOLEAN {:typeDate = ListType.BOOLEAN;:} onlyIDArray;
variableStirng ::= STRING {:typeDate = ListType.STRING;:} onlyIDArray;
variableObject ::= ID {:typeDate = ListType.OBJECT;:} onlyIDArray;
numEntero ::= BYTE {:typeDate = ListType.BYTE;:} onlyIDArray
| SHORT {:typeDate = ListType.SHORT;:} onlyIDArray
| INT {:typeDate = ListType.INT;:} onlyIDArray
| LONG {:typeDate = ListType.LONG;:} onlyIDArray 
;
//arreay [] | ID
onlyIDArray ::= ID:a {:nameVariable = a.toString();:}
| C_APERTURA  C_CIERRE {:arrayType();:} onlyIDArray
;

/*****************FINAL VARIABLE**************/
/*****************VARIABLES INDIALIZADAS DE UNA CLASE**************/
asignacionVariable ::=  IGUAL tDatos p
|p
;
//el uso del ()? tDatos : tDatos | ()? tDatos : ()? tDatos : tDatos
tDatos ::= P_APERTURA tDatos P_CIERRE tDatosFac
|tDatos IGUAL igualSimple tDatos
|tDatos MAYOR_Q menorYmayorIgual tDatos
|tDatos MENOR_Q menorYmayorIgual tDatos
|tDatos Y dosY tDatos
|tDatos O dosO tDatos
|tDatos ADMIRACION IGUAL dosO tDatos 
|tDatos SUMA tDatos
|tDatos RESTA tDatos
|tDatos DIVISION tDatos
|tDatos MULTIPLICACION tDatos
|tDatos MODULO tDatos
|vChar
|F
|L_APERTURA lCon
|NEW typeVarible newParentesisOCochtes
|FALSE
|TRUE
|ADMIRACION tDatos
|RESTA tDatos
|SUMA tDatos
|ENTERO
|DECIMAL
|TEXT textOperar
|usarOBJECT
;
newParentesisOCochtes ::= P_APERTURA  tFact
| C_APERTURA tDatos C_CIERRE
;
igualSimple ::=IGUAL
| SUMA
| RESTA
| DIVISION
| MULTIPLICACION
| MODULO
|
;
tDatosFac ::= 
| INTERO tDatos DOBLE_PUNTO tDatos
;
menorYmayorIgual ::= IGUAL
|
;
//para los char
vChar ::= SIMPLE_COMILLA CARACTER SIMPLE_COMILLA
| CHARTN
;
//esto para new id (parametos de objetos)
tFact ::= dSeguidoF P_CIERRE 
| P_CIERRE 
;
dSeguidoF ::= tDatos objectInst
;
objectInst ::= COMA dSeguidoF
|
;
// esto para crear arreglos{}
lCon ::= tDatos lConFact L_CIERRE
| L_CIERRE
;
lConFact ::=  COMA tDatos  lConFact
|
;
/*FINAL OPERADORES*/
textOperar ::= SUMA tDatos
|
;
dosY ::= Y
|
;
dosO ::= O
|
;
opBooleanIGUALFac ::=  tDatos
| IGUAL tDatos
;
/*OPERACION NUMERICA*/
j ::= operacionNumericaRecusividad {::}
;
operaionNumerica ::= 
;
operacionNumericaRecusividad ::= operacionNumericaPrima operacionNumericaTerminales operacionNumericaPrima
;
operacionNumericaPrima ::= SUMA  
|  RESTA  
|  DIVISION 
|  MULTIPLICACION 
|
;
operacionNumericaTerminales ::= RESTA operaionNumerica
| SUMA operaionNumerica
| ENTERO
| DECIMAL
| TEXT textOperar
| usarOBJECT
;
//USAR OBJECT
usarOBJECT ::= ID idDato
;
//ARRAY.LETER - 4 ,ID.ID(); //GET
idDato ::= PUNTO idDatoFac
|C_APERTURA j C_CIERRE idDato
|P_APERTURA dSeguidoF P_CIERRE
|P_APERTURA P_CIERRE
|
;
idDatoFac ::= ID  idGet
;
idGet ::= idDato
;
/*****************FINAL VARIABLES INDIALIZADAS DE UNA CLASE**************/
/***********************************METODOS**************/
metodo ::= {:nameMethods=nameVariable;typeMethods = typeDate;:} P_APERTURA pMetodoS P_CIERRE L_APERTURA  localMetodo  L_CIERRE 
|VOID {:typeMethods = ListType.VOID;:}  ID:a {:nameMethods = a.toString();:} P_APERTURA pMetodoS P_CIERRE L_APERTURA  localMetodo   L_CIERRE
|ID:a {:nameMethods = a.toString();:} P_APERTURA pMetodoS P_CIERRE L_APERTURA  localMetodo  L_CIERRE
;
//peticiiones de metodos
pMetodoS ::= variableID {:
            int aleft = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).left;
		    int aright = ((java_cup.runtime.Symbol)CUP$Sintactico$stack.peek()).right;
            addMethodsParameters(aleft,aright);
            :} pMetodoSP
|
;
pMetodoSP ::= COMA pMetodoS
| 
;
/***********************************FINAL METODOS**************/
/*LO QUE SE PUEDE HACER DENTRO DE UN METODO*/
localMetodo ::= local  localMetodo
|
;
local ::= variableLocal
|sentenciaControl
|terminalAccion
;
/*VARIALBES LOCALES DENTRO DE UN METODO*/
variableLocal ::= variableLocalFinal asignacionVariable
;
//VARIABLE FINAL 
variableLocalFinal ::= FINAL variableIDLocal
|variableIDLocal
|usarVariable
|terminalAccion
;
variableIDLocal ::= numFloat 
| numDouble 
| variableChar 
| variableBoolean 
| variableStirng  
| numEntero 
;
//asignar al set
loclaMetodFacto ::= PUNTO  ID  variableObjectUsarCrear
| ID 
|
;
variableObjectUsarCrear ::= P_APERTURA variableSet
|loclaMetodFacto
;
variableSet ::= tDatos secuenciDatos P_CIERRE 
|P_CIERRE
;
/*CUALQUIER ACCION menos colocar otra sentencia ya no es*/
usarVariable ::= ID usarVariableFacto
|THIS loclaMetodFacto
|SUPER soloId  P_APERTURA tDatos secuenciDatos P_CIERRE
;
soloId ::= PUNTO ID soloId
|
;
secuenciDatos ::=  COMA tDatos secuenciDatos
|
;
// id ++ id-- id+= id -=
usarVariableFacto ::= SUMA sumarIgual
|RESTA restarIgual
|loclaMetodFacto
|IGUAL tDatos
|C_APERTURA j C_CIERRE loclaMetodFacto
|P_APERTURA tDatos P_CIERRE
;
restarIgual ::= IGUAL tDatos
| RESTA
;
sumarIgual ::= IGUAL tDatos
| SUMA
;
terminalAccion ::= RETURN tDatos p
|BREAK p
;
/*VARIALBES LOCALES DENTRO DE UN METODO*/
/*SENTENCIAS DE CONTROL*/
sentenciaControl ::= WHILE P_APERTURA tDatos P_CIERRE L_APERTURA localMetodo L_CIERRE
|DO L_APERTURA localMetodo L_CIERRE WHILE P_APERTURA tDatos P_CIERRE p
|IF P_APERTURA tDatos P_CIERRE L_APERTURA localMetodo L_CIERRE sentenciaElse
|SWITCH P_APERTURA tDatos P_CIERRE L_APERTURA internoSwitch L_CIERRE
|FOR P_APERTURA inializarVariable  sentenciaFor
;
//sentencia try ca
//sentencia de switch
internoSwitch ::= CASE dSeguidoF  DOBLE_PUNTO localSwitch internoSwitch
|DEFAULT DOBLE_PUNTO localSwitch  
|
;
localSwitch ::= localSwitchDeclaracion  localSwitch 
|terminalAccion //esto de ultimo si o si
;
localSwitchDeclaracion ::= variableLocal
|sentenciaControl
;
//sentencia de for
sentenciaFor ::=  P_CIERRE L_APERTURA localMetodo L_CIERRE
| tDatos p usarVariable  P_CIERRE L_APERTURA localMetodo L_CIERRE
;
inializarVariable ::= variableIDFor asignacionVariable
| ID forVariableId
;  
variableIDFor ::= numFloat 
| numDouble 
| variableChar 
| variableBoolean 
| variableStirng 
| numEntero 
;
forVariableId ::= ID forVariableIdFac
| C_APERTURA C_CIERRE forVariableId
;
forVariableIdFac ::= DOBLE_PUNTO ID
| asignacionVariable
;
//USO DE IF ELSE IF ELSE
sentenciaElse ::= ELSE  sentenciaElseFac
|
;
sentenciaElseFac ::= L_APERTURA localMetodo L_CIERRE
|IF P_APERTURA tDatos P_CIERRE L_APERTURA localMetodo L_CIERRE sentenciaElse
;
/*FINAL SENTENCIAS DE CONTROL*/
/*FINAL LO QUE SE PUEDE HACER DENTRO DE UN METODO*/
/*FINAL PARTE DE LA CLASE*/